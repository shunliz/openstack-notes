**Part III：页表**

每一个进程都有一份页表（Page Table），作为其上下文的一部分。页表由一系列页表条目（PTE，Page Table Entry）组成，每个页表条目都包含着虚拟页和物理页的映射关系。PTE 由一个有效位（valid bit，表明该虚拟页是否被缓存在 DRAM 中）和一个 n 位地址字段组成。

页表（page table）的数据结构存放在物理内存（DRAM）中，操作系统负责维护页表结构，每次 MMU（内存管理单元）中的地址翻译硬件将一个虚拟地址转换成物理地址时，都会读取页表。

MMU 通过页表来确定一个虚拟页是否缓存在 DRAM 中：

* 如果是（有效位为 1）
  ，则该条目指向该虚拟页所存放在物理页的位置；
* 如果不是（有效位为 0）
  ，则该条目指向该虚拟页所存放在磁盘的位置，在物理内存（DRAM）中选择一个牺牲页，并将虚拟页从磁盘复制到 DRAM 中，替换这个牺牲页。

![](/assets/compute-arch-vmm-pagetable1.png)

上图为包含 8个虚拟页，4 个物理页的系统的页表结构。

**Part IV：页命中**

页命中指的是当 MMU 需要根据虚拟地址输出物理地址时，这个地址所在的页已经被装载到物理内存中了（即对应的 PTE 的有效为 1）。

![](/assets/compute-arch-vmm-pagehit1.png)

上图中，当 MMU 访问的虚拟地址对应到页表中 VP 2 时，地址翻译硬件发现该地址在页表当中有效位为 1，即被缓存在 DRAM 当中（称为页命中），则使用页表当中 PTE 所对应的物理内存地址，来访问数据。

**Part V：缺页**

![](/assets/compute-arch-vmm-pagefault1.png)

上图中，当 MMU 访问的虚拟地址对应到页表中 VP 3 时，地址翻译硬件发现该地址在页表当中有效位为 0，即未被缓存在 DRAM 当中，称为缺页（Page Fault），触发一个缺页异常。

缺页异常的处理程序被启动，该程序会选择一个牺牲页，若是该牺牲页被标记为已经更改过，则内核会将其复制回磁盘，若是未更改过，调整牺牲页在页表中所对应的 PTE。接着，内核从磁盘\(虚拟内存\)当中将内容复制到牺牲页\(物理内存\)上，再次更新其PTE，随后返回。

当缺页异常处理程序返回时，原进程会重新启动导致缺页异常的指令，该指令会将导致缺页的虚拟地址重发送到地址翻译硬件，这时就会进行页命中的相关流程了。

![](/assets/compute-arch-vmm-pagefault2.png)

上图中，触发缺页异常后，缺页异常处理程序选择 VP 4 作为牺牲页，并从磁盘上用 VP 3 的副本取代它。

![](/assets/compute-arch-vmm-pagefault3.png)

在缺页异常处理程序重新启动导致缺页的指令之后，该指令将从内存中正常地读取字，而不会再产生缺页异常。

**Part VI：分配新页**

![](/assets/comput-arch-vmm-newpage.png)

如上图，内核在磁盘上分配 VP 5，并将 PTE 5 指向这个新的位置。

**Part VII：虚拟内存作为内存管理的工具**

操作系统为每个进程提供了一个独立的页表，也就是每个进程独占一个独立的虚拟地址空间。

![](/assets/compute-arch-vmm-processvm1.png)

这样做的好处：

这样做的好处：

* 简化共享内存
  ：操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享下共同代码的副本。
* 简化链接
  ：独立的地址空间允许每个进程的内存布局使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。链接器可以假设每个程序都加载到相同的位置，然后它可以重定位这些引用。
* 简化加载
  ：execve 查看 ELF 文件，它知道文件中的代码和数据段有多大，它从固定的地址为代码和数据分配虚拟内存。
* 简化内存分配
  ：虚拟内存为向用户进程提供一个简单的分配额外内存的机制。当一个运行在用户进程中的程序要求额外的堆空间时（如调用malloc），操作系统分配一个适当数字（eg：k）个连续的虚拟内存页面，并且将他们映射到物理内存中任意位置的 k 个任意的物理页面。

**Part VIII：虚拟内存作为内存保护的工具**

虚拟内存通过在 PTE 上添加一些额外的许可位来控制对一个虚拟页面的访问权限，通过虚拟内存可以提供页面级的内存保护。

![](/assets/compute-arch-vmm-pageflags.png)符号

|  | 描述 |
| :--- | :--- |
| VPO（Virtual Page Offset） | 虚拟页面偏移量（字节） |
| VPN（Virtual Page Number） | 虚拟页号 |
| TLBI（TLB Index） | TLB 索引 |
| TLBT（TLB Tag） | TLB 标记 |

**3. 物理地址（PA）的组成部分**

| 符号 | 描述 |
| :--- | :--- |
| PPO（Physical Page Offset） | 物理页面偏移量（字节） |
| PPN（Physical Page Number） | 物理页号 |
| CO（Byte offset within cache line） | 缓存行内的字节偏移量 |
| CI（Cache index） | 高速缓存索引 |
| CT（Cache tag） | 高速缓存标记 |

**Part II：使用页表的地址翻译**

在 CPU 中地址翻译由一个叫做 MMU（Memory Management Unit，内存管理单元）的硬件完成。MMU 接收一个虚拟地址，并且输出一个物理地址。如果这个虚拟地址在物理内存中存在，那么就叫做页命中。如果这个虚拟地址在物理内存中不存在，那么 MMU 将产生一个缺页错误。

![](/assets/compute-archtiecture-mmu1.png)n 位的虚拟地址包括两个部分：一个 p 位的虚拟页面偏移（Virtual Page Offset，VPO），和一个 n-p 位的虚拟页号（Virtual Page Number， VPN），MMU 利用 VPN 来选择适当的 PTE。

因为物理和虚拟页面都是 P 字节的，所以物理页面偏移（Physical Page Offset，PPO）和 虚拟页面偏移（Virtual Page Offset，VPO）是相同的，因此将 PTE 中的物理页号（Physical Page Number， PPN）与 VPO 串联起来，就得到了相应的物理地址。

#### 

#### **页命中时地址翻译**

![](/assets/comupte-architecture-mmu2.png)

1. 处理器生成一个虚拟地址，并把它传送给 MMU。

2. MMU 生成根据虚拟地址生成 VPN，然后请求高速缓存/主存，获取 PTE 的数据。

3. 高速缓存/主存向 MMU 返回 PTE 的数据。

4. 从 PTE 获取对应的物理页号 PPN。用物理页的基址加上页偏移 PPO（假设页大小为 4KB，那么页偏移就是虚拟地址的低 12 位，物理页的页偏移和虚拟页的页偏移相同），获取对应的物理地址。

5. 主存/高速缓存将数据返回给 CPU。

**2.缺页时的地址翻译**

![](/assets/compute-architecture-mmu3.png)

1. 处理器生成一个虚拟地址，并把它传送给 MMU。

2. MMU 根据虚拟地址生成 VPN，然后请求高速缓存/主存，获取 PTE 的数据。

3. 高速缓存/主存向 MMU 返回 PTE 的数据。

4. 由于判断出 PTE 的有效位是 0，所以 CPU 将触发一次异常，将控制权转移给内核中的缺页异常处理程序。

5. 缺页异常处理程序确定出物理内存中的牺牲页，如果这个页面被修改过了（D 标志位为 1），那么将牺牲页换出到磁盘。

6. 缺页处理程序从磁盘中调入新的页面到主存中，并且更新 PTE。

7. 缺页处理程序将控制权返回给原来的进程，再次执行导致缺页的指令。再次执行后，就会产生页命中时的情况了。



